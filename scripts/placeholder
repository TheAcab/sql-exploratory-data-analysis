
select 
year (order_date) order_year,		--year function extracts the year from a date
sum (sales_amount) total_sales,
count(distinct customer_key) as total_customers	,
sum(quantity) total_quantity
from gold.fact_sales

where order_date is not null
group by year (order_date)
order by year (order_date)


---same calculation by month
select 
month (order_date) order_month,		--month function extracts the month from a date
sum (sales_amount) total_sales,
count(distinct customer_key) as total_customers	,
sum(quantity) total_quantity
from gold.fact_sales

where order_date is not null
group by month (order_date)
order by month (order_date)

--same calculation from year and month

select 

year (order_date) order_year,
month (order_date) order_month,		--month function extracts the month from a date
sum (sales_amount) total_sales,
count(distinct customer_key) as total_customers	,
sum(quantity) total_quantity
from gold.fact_sales

where order_date is not null
group by year (order_date) , MONTH (order_date)
order by year (order_date) , month (order_date)

--date trunc function joins/ filters the dates together
select 
DATETRUNC (month, order_date) as order_date,		--can be changed to month
sum (sales_amount) total_sales,
count(distinct customer_key) as total_customers	,
sum(quantity) total_quantity
from gold.fact_sales

where order_date is not null
group by  DATETRUNC (month, order_date)
order by  DATETRUNC (month, order_date)

--date format option
select 
format (order_date,'yyyy-MMM') as order_date,		-- must provide column name and new format
sum (sales_amount) total_sales,
count(distinct customer_key) as total_customers	,
sum(quantity) total_quantity
from gold.fact_sales

where order_date is not null
group by  format (order_date,'yyyy-MMM')		--this format cannot be sorted by the month, only the year as this is a string
order by  format (order_date,'yyyy-MMM')
--calculate the total sales per month and the running total of sales over time

select
order_date,
sales_amount
from gold.fact_sales

select																																									--6.
order_date,																																						--7.
total_sales,																																							--8.
sum(total_sales) over (order by order_date) as running_total_sales --creates a column that add the previous sales to the current sales
from (																																									--9.
select																																									--1.
datetrunc (month, order_date) order_date,		--this function truncates/ filters the sales per month		--2.
sum (sales_amount) as total_sales																													--3.
from gold.fact_sales																																			--4.

where order_date is not null																															--5.
group by datetrunc (month, order_date)
)t																																											--9.1


select 43419 + 469795

---to reset the values by year...

select																																									--6.
order_date,																																						--7.
total_sales,																																							--8.
sum(total_sales) 
over (partition by order_date order by order_date) as running_total_sales --creates a column that add the previous sales to the current sales
from 
(																																											--9.
select																																									--1.
datetrunc (month, order_date) order_date,		--this function truncates/ filters the sales per month		--2.
sum (sales_amount) as total_sales																													--3.
from gold.fact_sales																																			--4.

where order_date is not null																															--5.
group by datetrunc (month, order_date)
)t				

--running totals over the years, with moving avg--------------------------------------------------------------------------------------------------------
select																																									--6.
order_date,																																						--7.
total_sales,																																							--8.
sum(total_sales) over (  order by order_date) as running_total_sales, --creates a column that add the previous sales to the current sales
avg (avgprice) over (  order by order_date) as moving_average
from 
(																																											--9.
select																																									--1.
datetrunc (YEAR, order_date) order_date,		--this function truncates/ filters the sales per month		--2.
sum (sales_amount) as total_sales,
AVG(price) as avgprice																																	--3.
from gold.fact_sales																																			--4.

where order_date is not null																															--5.
group by datetrunc (YEAR, order_date)
)t				


--Analyse the yearly performance of products by comparing each products sales 
--to both its average sales performance and the previous years sales

with yearly_product_sales as																			--1. this function creates a query with in a query

	(select 
	year (f.order_date) as order_year,
	p.product_name,
	sum(f.sales_amount) as current_sales
	from gold.fact_sales f

	left join gold.dim_products p
	on f.product_key = p.product_key

	where f.order_date is not null
	group by
	year(f.order_date),
	p.product_name)

select																													--2. this is the follow up query
order_year,
product_name,
current_sales,
avg(current_sales) over (partition by product_name) avg_sales,
current_sales - AVG (current_sales) over (partition by product_name) as diff_avg,
case when current_sales - avg(current_sales) over (partition by product_name) > 0 then 'Above avg'
		  when current_sales - avg(current_sales) over (partition by product_name) < 0 then 'Below avg' 
		  else 'Avg'
end avg_change,
-- Year over Year
lag(current_sales) 
over (partition by product_name order by order_year) py_sales, --to access data from a previous row within the same result set
current_sales - lag(current_sales) over (partition by product_name order by order_year) as diff_py,

case when current_sales - lag(current_sales) over (partition by product_name order by order_year) > 0 then 'Increase'
		  when current_sales - lag(current_sales) over (partition by product_name order by order_year) < 0 then 'Decrease' 
		  else 'No Change'
end avg_change

from yearly_product_sales

order by product_name, order_year																--3. the entire scrip must be run to produce a result
use DataWarehouse

--which cetegories contribute the most to the overall sales?
with category_sales as(
select 
category,
sum (sales_amount) total_sales
from gold.fact_sales f

left join	gold.dim_products p
on p.PRODUCT_key = f.product_key

group by category)

select
category,
total_sales,

sum(total_sales) over () overallsales, 
concat															--concat function combines text (in this case the '%' character)
( round((cast(total_sales as float)/				 --round function rounds to selected value (2 decimal points)
sum (total_sales) over ()) *100,2) , '%')
as percentage_of_total								 --cast canges data type, float converts to floating number/ decimal point

from category_sales
order by total_sales desc
--segment products into cost ranges and count how many products fall into each segment
with product_segments as 
(select 
PRODUCT_key,
product_name,
cost,
case when cost <100 then 'Below 100'
			when cost between 100 and 500 then '100-500'
			when cost between 500 and 1000 then '500-1000'
			else 'Above 1000'
end cost_range																	--new column name
from gold.dim_products)

select 
cost_range,
count(product_key) as total_products
from product_segments
group by cost_range
order by total_products desc

--Group customers into three segments vased on their spending behaviour:
--VIP: customers with 12 months of history and spending more than 5000
--Regulare: 12 months of history but spending less than 5000
--New: customers with less than 12 months history
--find the total number of customers by each group
with customer_spending as
(select 
c.customer_key,
sum (f.sales_amount)total_spending,
min (order_date) first_order,
max(order_date) last_order,
datediff(month, min(order_date), max (order_date)) as lifespan
from gold.fact_sales f

left join gold.dim_customers c
on f.customer_key = c.customer_key

group by c.customer_key)

select 
customer_segment,
count(customer_key) as total_customers
from
(select customer_key,
case when lifespan >= 12 and total_spending > 5000 then 'VIP'
			when lifespan >= 12 and total_spending <= 5000 then 'Regular'
else 'New'
end customer_segment
from customer_spending) t
group by customer_segment
order by total_customers


--Customer report
----------------------------
--Purpose"
	-- this report consolidates key customer metrics and behaviours

--Highlights:
	--1. Gathers essential fields such as names, ages, and transactions details
	--2. Segments customer into categories (VIP, Regular, New) and age groups.
	--3. Aggregates customer level metrics:
		--total sales
		--total orders
		--total qty purchased
		--lifespan (in months)
	--4. Calculates valuable KPIs:
		--recency (months since last order)
		--average order value
		--average monthly spend

	--retrive core columns


	create view gold.report_customers as



	with base_query as (																						--4.
	-- 1) Base query: retrieves core columns from tables
select																													--1.
	f.order_number,																								--3
	f.product_key,
	f.order_date,
	f.sales_amount,
	f.quantity,
	c.customer_key,
	c.customer_number,
	CONCAT( c.first_name, ' ' , c.last_name) as customer_name,
	c.birthdate,
	DATEDIFF(year, c.birthdate, GETDATE()) age											--3.1
	from gold.fact_sales f	

	left join gold.dim_customers c																		--2.
	on c.customer_key  = f.customer_key														--2.1

	where order_date is not null)

	,customer_aggregation as(
	--2) Customer aggregations: Summarizes key metrics at customer level
	select																												--5
	customer_key,
	customer_number,
	customer_name,
	age,
	count(distinct order_number) as total_orders,
	sum(sales_amount) as total_sales,
	sum (quantity) as total_quantity,
	count(distinct product_key) as total_products,
	max(order_date) as last_order_date,
	DATEDIFF(MONTH, min(order_date), max(order_date)) as lifespan


	from base_query
	group by																											--6
		customer_key,
		customer_number,
		customer_name,
		age)

	select
		customer_key,
		customer_number,
		customer_name,
		age,
		case 
			when age < 20 then 'Under20'
			when age between 20 and 29 then '20-29'
			when age between 30 and 39 then '30-39'
			when age between 40 and 49 then '40-49'
			else '50 and above'
		end as age_group,
		case
			when lifespan > = 12 and total_sales > 5000 then 'VIP'
			when lifespan > = 12 and total_sales < = 5000 then 'Regular'
			else 'New'
		end as customer_segment,
		last_order_date,
		DATEDIFF (MONTH, last_order_date, getdate()) as recency,
		total_orders,
		total_sales,
		total_quantity,
		 lifespan,
-- calculate average order value (AV0)
case when total_sales = 0 then 0		--use this formula to avoid deviding by zero and retrieve incorrect results
	else total_sales / total_orders
end as avg_order_value,

--calculate avg monthly spend
case when lifespan = 0 then total_sales
	else total_sales / lifespan
end as avg_monthly_spend
		from  customer_aggregation;

--1. Gather essenatial columns
--2. Segment by revenue (high, mid and low performers)
--3. Aggregate:	total orders, total sales, total qty sold, total customer (unique), lifespan
--4. Calculate valuables kpi's: recency (months since last sales), avg order revenue(AOR), avg monthly revenue

--1. Gather essenatial columns
create view  gold.report_products as

with product_query_base as (
select 
f.order_number,
f.order_date,
f.customer_key,
f.sales_amount,
f.quantity,
p.PRODUCT_key,
p.product_name,
p.category,
p.subcategory,
p.cost
from gold.fact_sales f

left join gold.dim_products p
on p.PRODUCT_key = f.product_key

where order_date is not null ),

----------------------------------------------------
--Aggregate:	total orders, total sales, total qty sold, total customer (unique), lifespan--
product_aggregations as(
select 
	product_key,
	product_name,
	category,
	subcategory,
	cost,
	datediff(month, min (order_date), max(order_date)) as lifespan,
	max (order_date) as last_sales_date,
	count(distinct order_number) as total_orders,
	count(distinct customer_key) as total_customers,
	sum(sales_amount) as total_sales,
	sum(quantity) as total_quantity,
	round(avg(cast(sales_amount as float) / nullif(quantity, 0)),1) as avg_selling_price
	from product_query_base

	group by
	product_key,
	product_name,
	category,
	subcategory,
	cost)

	select 
	PRODUCT_key,
	product_name,
	category,
	subcategory,
	cost,
	last_sales_date,
	datediff(month, last_sales_date, GETDATE()) as recency_in_months,
	CASe	
		when total_sales > 50000 then 'High Performer'
		when total_sales>= 10000 then 'Mid Range'
		else 'Low performer'
	end as product_segment,
	lifespan,
	total_orders,
	total_sales,
	total_quantity,
	total_customers,
	avg_selling_price,
		case 
			when total_customers = 0 then 0 
			else total_sales / total_orders
		end as avg_order_revenue,

		case 
			when lifespan = 0 then total_sales
			else total_sales/ lifespan
		end as avg_monthly_revenue
	from product_aggregations
	
